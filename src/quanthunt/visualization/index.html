<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MOSAIC K Dashboard</title>

  <!-- MQTT over WebSocket -->
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <!-- Lightweight Charts v3 -->
  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      margin: 0;
      padding: 12px;
    }
    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    select {
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #374151;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 13px;
    }
    #status {
      font-size: 12px;
      color: #9ca3af;
    }
    .risk-light {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
    }
    .risk-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      opacity: 0.25;
    }
    #risk-green { background: #22c55e; }
    #risk-yellow { background: #eab308; }
    #risk-red { background: #ef4444; }

    .chart-container {
      border-radius: 8px;
      background: #020617;
      padding: 6px;
      margin-bottom: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    }
    .chart-title {
      font-size: 13px;
      margin-bottom: 4px;
      color: #9ca3af;
    }
    #raw-log-container {
      border-radius: 8px;
      background: #020617;
      padding: 6px;
      margin-top: 4px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.4);
    }
    #raw-log-title {
      font-size: 13px;
      margin-bottom: 4px;
      color: #9ca3af;
    }
    #raw-log {
      height: 120px;
      overflow-y: auto;
      background: #020617;
      border: 1px solid #1f2937;
      padding: 4px;
      font-family: "SF Mono", ui-monospace, Menlo, Monaco, Consolas, monospace;
      font-size: 11px;
      white-space: pre;
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div class="controls">
      <label for="symbolSelect">Symbol:</label>
      <select id="symbolSelect">
        <option value="btcusdt">BTC</option>
        <option value="nearusdt">NEAR</option>
        <option value="kitusdt">KIT</option>
        <option value="solusdt">sol</option>
        <option value="bnbusdt">bnb</option>
        <option value="xrpusdt">XRP</option>
        <option value="adausdt">ADA</option>
      </select>

      <label for="intervalSelect">Interval:</label>
      <select id="intervalSelect">
        <option value="1min">1m</option>
        <option value="5min">5m</option>
        <option value="15min">15m</option>
        <option value="30min">30m</option>
        <option value="60min" selected>1hr</option>
        <option value="4hour">4hr</option>
        <option value="1day">1day</option>
      </select>

      <span id="status">Connecting...</span>
    </div>

    <div class="risk-light">
      Risk:
      <div class="risk-dot" id="risk-green"></div>
      <div class="risk-dot" id="risk-yellow"></div>
      <div class="risk-dot" id="risk-red"></div>
    </div>
  </div>

  <div class="chart-container">
    <div class="chart-title">Close + Orders</div>
    <div id="close_chart" style="width: 100%; height: 260px;"></div>
  </div>

  <div class="chart-container">
    <div class="chart-title">Regime Zone</div>
    <div id="regime_chart" style="width: 100%; height: 80px;"></div>
  </div>

  <div class="chart-container">
    <div class="chart-title">m_force</div>
    <div id="force_chart" style="width: 100%; height: 200px;"></div>
  </div>

  <div id="raw-log-container">
    <div id="raw-log-title">Raw JSON Log (last 50)</div>
    <pre id="raw-log"></pre>
  </div>

  <script>
    const MQTT_URL = "ws://localhost:9010";
    const MAX_POINTS = 2000;
    const MAX_LOG_LINES = 50;
    const LOG_VALUE_LEN = 20;

    const statusEl = document.getElementById("status");
    const symbolSelect = document.getElementById("symbolSelect");
    const intervalSelect = document.getElementById("intervalSelect");
    const rawLogEl = document.getElementById("raw-log");

    const riskGreen = document.getElementById("risk-green");
    const riskYellow = document.getElementById("risk-yellow");
    const riskRed = document.getElementById("risk-red");

    let currentTopic = null;
    let client = mqtt.connect(MQTT_URL);
    let lastTime = null; // 幂等去重用

    // Chart setup
    const closeChart = LightweightCharts.createChart(
      document.getElementById("close_chart"),
      {
        width: document.getElementById("close_chart").clientWidth,
        height: 260,
        layout: { background: { color: "#020617" }, textColor: "#e5e7eb" },
        grid: {
          vertLines: { color: "#111827" },
          horzLines: { color: "#111827" },
        },
        timeScale: {
          borderColor: "#1f2937",
          timeVisible: true,      // ← 顯示 HH:mm
          secondsVisible: false, // ← 1m / 5m / 15m 用 false
        },
        rightPriceScale: { borderColor: "#1f2937" },
        localization: {
          timeFormatter: (timestamp) => {
            const d = new Date(timestamp * 1000);
            return d.toLocaleString("zh-TW", {
              hour12: false,
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
            });
          },
        },
      }
    );

    const regimeChart = LightweightCharts.createChart(
      document.getElementById("regime_chart"),
      {
        width: document.getElementById("regime_chart").clientWidth,
        height: 80,
        layout: { background: { color: "#020617" }, textColor: "#e5e7eb" },
        grid: {
          vertLines: { color: "#111827" },
          horzLines: { color: "#111827" },
        },
        timeScale: {
          borderColor: "#1f2937",
          timeVisible: true,      // ← 顯示 HH:mm
          secondsVisible: false, // ← 1m / 5m / 15m 用 false
        },
        rightPriceScale: {
          borderColor: "#1f2937",
          visible: false,
        },
        localization: {
          timeFormatter: (timestamp) => {
            const d = new Date(timestamp * 1000);
            return d.toLocaleString("zh-TW", {
              hour12: false,
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
            });
          },
        },
      }
    );

    regimeChart.applyOptions({
      handleScroll: false,
      handleScale: false,
      crosshair: {
        mode: LightweightCharts.CrosshairMode.Hidden,
      },
    });

    const forceChart = LightweightCharts.createChart(
      document.getElementById("force_chart"),
      {
        width: document.getElementById("force_chart").clientWidth,
        height: 200,
        layout: { background: { color: "#020617" }, textColor: "#e5e7eb" },
        grid: {
          vertLines: { color: "#111827" },
          horzLines: { color: "#111827" },
        },
        timeScale: {
          borderColor: "#1f2937",
          timeVisible: true,      // ← 顯示 HH:mm
          secondsVisible: false, // ← 1m / 5m / 15m 用 false
        },
        rightPriceScale: { borderColor: "#1f2937" },
        localization: {
          timeFormatter: (timestamp) => {
            const d = new Date(timestamp * 1000);
            return d.toLocaleString("zh-TW", {
              hour12: false,
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
            });
          },
        },
      }
    );

    forceChart.applyOptions({
      handleScroll: false,
      handleScale: false,
    });

    forceChart.priceScale('left').applyOptions({
      scaleMargins: {
        top: 0.15,
        bottom: 0.15,
      },
    });

    forceChart.priceScale('right').applyOptions({
      scaleMargins: {
        top: 0.15,
        bottom: 0.15,
      },
    });

    const closeSeries = closeChart.addLineSeries({
      color: "rgba(96, 165, 250, 1)",
      lineWidth: 2,
    });

    const hmmBgSeries = closeChart.addAreaSeries({
      priceScaleId: "", // ⭐ overlay，不吃價格軸
      topColor: "rgba(59, 130, 246, 0.15)",   // 藍色背景
      bottomColor: "rgba(59, 130, 246, 0.15)",
      lineColor: "rgba(0,0,0,0)",
      lineWidth: 0,
      crosshairMarkerVisible: false,
      lastValueVisible: false,
    });

    // Regime histogram strip
    const regimeSeries = regimeChart.addHistogramSeries({
      base: 0,
    });

    // m_force histogram
    const forceSeries = forceChart.addHistogramSeries({
      priceScaleId: "left",
      base: 0,
    });

    const ptSpeedSeries = forceChart.addHistogramSeries({
      priceScaleId: "right",
      base: 0,
    });

    const forceTrendSeries = forceChart.addLineSeries({
      priceScaleId: "right",
      color: "rgba(96, 165, 250, 1)", // 藍線
      lineWidth: 2,
    });

    // closeChart.timeScale().fitContent();
    // const range = closeChart.timeScale().getVisibleLogicalRange();
    // regimeChart.timeScale().setVisibleLogicalRange(range);
    // forceChart.timeScale().setVisibleLogicalRange(range);
    syncFromMaster(closeChart, [regimeChart, forceChart]);

    let closeData = [];
    let hmmBgData = [];
    let forceData = [];
    let ptSpeedData = [];
    let forceTrendData = [];
    let regimeData = [];
    let orderMarkers = [];
    let rawLogs = [];
    let firstApply = true;

    function syncFromMaster(masterChart, slaveCharts) {
      masterChart.timeScale().subscribeVisibleLogicalRangeChange(range => {
        if (!range) return;
        slaveCharts.forEach(c => {
          c.timeScale().setVisibleLogicalRange(range);
        });
      });
    }


    function buildTopic(symbol, interval) {
      console.log(`mkt/${symbol.toLowerCase()}/${interval}/k_channel`)
      return `mkt/${symbol.toLowerCase()}/${interval}/k_channel`;
    }

    function dateToUnixSeconds(dateStr) {
      const d = new Date(dateStr);
      if (isNaN(d.getTime())) {
        return Math.floor(Date.now() / 1000);
      }
      return Math.floor(d.getTime() / 1000);
    }

    function updateRiskLight(risk) {
      let g = 0.2, y = 0.2, r = 0.2;
      if (risk <= 0.33) {
        g = 1.0;
      } else if (risk <= 0.66) {
        y = 1.0;
      } else {
        r = 1.0;
      }
      riskGreen.style.opacity = g;
      riskYellow.style.opacity = y;
      riskRed.style.opacity = r;
    }

    function trimVal(val, maxLen) {
      let s;
      if (val === null || typeof val === "undefined") {
        s = "null";
      } else if (typeof val === "object") {
        if (val && val.side) {
          s = val.side;
        } else {
          s = JSON.stringify(val);
        }
      } else {
        s = String(val);
      }
      if (s.length > maxLen) return s.slice(0, maxLen);
      return s.padEnd(maxLen, " ");
    }

    function appendRawLog(obj) {
      const keys = Object.keys(obj).sort();
      const parts = keys.map(k => `${k}=${trimVal(obj[k], LOG_VALUE_LEN)}`);
      const line = parts.join(" | ");
      rawLogs.push(line);
      if (rawLogs.length > MAX_LOG_LINES) {
        rawLogs = rawLogs.slice(-MAX_LOG_LINES);
      }
      rawLogEl.textContent = rawLogs.join("\n");
      rawLogEl.scrollTop = rawLogEl.scrollHeight;
    }

    function resetData() {
      closeData = [];
      hmmBgData = [];
      forceData = [];
      ptSpeedData = [];
      forceTrendData = [];
      regimeData = [];
      orderMarkers = [];
      firstApply = true;

      closeSeries.setData([]);
      hmmBgSeries.setData([]);
      forceSeries.setData([]);
      ptSpeedSeries.setData([]);
      forceTrendSeries.setData([]);
      regimeSeries.setData([]);
      closeSeries.setMarkers([]);
      rawLogs = [];
      rawLogEl.textContent = "";
      updateRiskLight(0);
    }

    function pushPoint(row) {
      const t = dateToUnixSeconds(row.Date);

      // =====================
      // 1) 幂等去重（防 MQTT 重送）
      // =====================
      if (lastTime !== null && t <= lastTime) {
        return;
      }
      lastTime = t;

      const close = Number(row.Close);
      const hmmSignal = Number(row.HMM_Signal ?? 0);
      const m_force = Number(row.m_force);
      const regime = row.m_regime_noise_level ?? 0;
      const risk = row.bocpd_risk ?? 0.0;
      const order = row.order || null;
      const m_pt_speed = Number(row.m_pt_speed);
      const m_force_trend = Number(row.m_force_trend);

      // =====================
      // 2) append（先加）
      // =====================
      closeData.push({ time: t, value: close });

      // 用 1 / null，当成时间遮罩
      hmmBgData.push({
        time: t,
        value: hmmSignal === 1 ? 1 : null,
      });

      // 裁切要同步
      if (hmmBgData.length > MAX_POINTS) {
        hmmBgData = hmmBgData.slice(-MAX_POINTS);
      }

      // streaming 更新
      hmmBgSeries.update({
        time: t,
        value: hmmSignal === 1 ? 1 : null,
      });

      const forceColor =
        m_force >= 0
          ? "rgba(52, 211, 153, 0.8)"
          : "rgba(248, 113, 113, 0.8)";
      forceData.push({ time: t, value: m_force, color: forceColor });

      const speedColor =
        m_pt_speed >= 0
          ? "rgba(34, 197, 94, 0.8)"
          : "rgba(239, 68, 68, 0.8)";
      ptSpeedData.push({ time: t, value: m_pt_speed, color: speedColor });

      forceTrendData.push({ time: t, value: m_force_trend });

      let regimeColor = "rgba(148, 163, 184, 0.8)";
      if (regime > 1.15) regimeColor = "rgba(34, 197, 94, 0.8)";
      else if (regime < 0) regimeColor = "rgba(248, 113, 113, 0.9)";
      regimeData.push({ time: t, value: regime, color: regimeColor });

      // =====================
      // 3) 裁切（再砍）
      // =====================
      if (closeData.length > MAX_POINTS) {
        closeData = closeData.slice(-MAX_POINTS);
        forceData = forceData.slice(-MAX_POINTS);
        ptSpeedData = ptSpeedData.slice(-MAX_POINTS);
        forceTrendData = forceTrendData.slice(-MAX_POINTS);
        regimeData = regimeData.slice(-MAX_POINTS);

        const minTime = closeData[0].time;
        orderMarkers = orderMarkers.filter(m => m.time >= minTime);
      }

      // =====================
      // 4) markers
      // =====================
      if (order && order.side) {
        const side = String(order.side).toUpperCase();
        if (side === "BUY" || side === "SHORT") {
          orderMarkers.push({
            time: t,
            position: side === "BUY" ? "belowBar" : "aboveBar",
            color:
              side === "BUY"
                ? "rgba(34, 197, 94, 1)"
                : "rgba(239, 68, 68, 1)",
            shape: side === "BUY" ? "arrowUp" : "arrowDown",
            text: side === "BUY" ? "B" : "S",
          });
        }
      }

      // =====================
      // 5) streaming 更新（⚠️关键）
      // =====================
      closeSeries.update({ time: t, value: close });
      forceSeries.update({ time: t, value: m_force, color: forceColor });
      ptSpeedSeries.update({ time: t, value: m_pt_speed, color: speedColor });
      forceTrendSeries.update({ time: t, value: m_force_trend });
      regimeSeries.update({ time: t, value: regime, color: regimeColor });
      closeSeries.setMarkers(orderMarkers);

      updateRiskLight(risk);
    }


    function applyDataToSeries(isInitial = false) {
      closeSeries.setData(closeData);
      forceSeries.setData(forceData);
      ptSpeedSeries.setData(ptSpeedData);
      forceTrendSeries.setData(forceTrendData);
      regimeSeries.setData(regimeData);
      closeSeries.setMarkers(orderMarkers);

      if (isInitial || firstApply) {
        closeChart.timeScale().fitContent();
        regimeChart.timeScale().fitContent();
        forceChart.timeScale().fitContent();
        firstApply = false;
      }
    }

    // MQTT events
    client.on("connect", () => {
      statusEl.textContent = "Connected";
      switchStream(symbolSelect.value, intervalSelect.value);
    });

    client.on("reconnect", () => {
      statusEl.textContent = "Reconnecting...";
    });

    client.on("error", (err) => {
      statusEl.textContent = "MQTT error: " + err.message;
    });

    function requestHistory(symbol, interval) {
      const topic = `mkt/${symbol}/${interval}/request`;
      client.publish(topic, JSON.stringify({
        type: "sync",
      }));
    }

    function switchStream(symbol, interval) {
      const newTopic = buildTopic(symbol, interval);
      if (newTopic === currentTopic) return;

      if (currentTopic) {
        client.unsubscribe(currentTopic);
      }
      currentTopic = newTopic;
      resetData();

      if (client.connected) {
        client.subscribe(currentTopic, (err) => {
          if (err) {
            statusEl.textContent = "Subscribe error: " + err.message;
          } else {
            statusEl.textContent = "Subscribed: " + currentTopic;
          }
        });
      } else {
        statusEl.textContent = "Waiting for MQTT connection...";
      }
      requestHistory(symbol, interval)
    }

    symbolSelect.addEventListener("change", () => {
      switchStream(symbolSelect.value, intervalSelect.value);
    });

    intervalSelect.addEventListener("change", () => {
      switchStream(symbolSelect.value, intervalSelect.value);
    });

    client.on("message", (topic, message) => {
      if (topic !== currentTopic) return;

      const data = JSON.parse(message.toString());

      // ========= batch =========
      if (data.batch && Array.isArray(data.rows)) {
        resetData();

        data.rows.forEach(row => {
          const t = dateToUnixSeconds(row.Date);
          lastTime = t;

          const close = Number(row.Close);
          const hmmSignal = Number(row.HMM_Signal ?? 0);
          const m_force = Number(row.m_force);
          const m_pt_speed = Number(row.m_pt_speed);
          const m_force_trend = Number(row.m_force_trend);
          const regime = row.m_regime_noise_level ?? 0;
          const order = row.order || null;

          // close
          closeData.push({ time: t, value: close });

          hmmBgData.push({
            time: t,
            value: hmmSignal === 1 ? 1 : null,
          });
          // m_force
          const forceColor =
            m_force >= 0
              ? "rgba(52, 211, 153, 0.8)"
              : "rgba(248, 113, 113, 0.8)";
          forceData.push({ time: t, value: m_force, color: forceColor });

          // pt speed
          const speedColor =
            m_pt_speed >= 0
              ? "rgba(34, 197, 94, 0.8)"
              : "rgba(239, 68, 68, 0.8)";
          ptSpeedData.push({ time: t, value: m_pt_speed, color: speedColor });

          // force trend
          forceTrendData.push({ time: t, value: m_force_trend });

          // regime
          let regimeColor = "rgba(148, 163, 184, 0.8)";
          if (regime > 1.15) regimeColor = "rgba(34, 197, 94, 0.8)";
          else if (regime < 0) regimeColor = "rgba(248, 113, 113, 0.9)";
          regimeData.push({ time: t, value: regime, color: regimeColor });

          // markers
          if (order && order.side) {
            const side = String(order.side).toUpperCase();
            if (side === "BUY" || side === "SHORT") {
              orderMarkers.push({
                time: t,
                position: side === "BUY" ? "belowBar" : "aboveBar",
                color:
                  side === "BUY"
                    ? "rgba(34, 197, 94, 1)"
                    : "rgba(239, 68, 68, 1)",
                shape: side === "BUY" ? "arrowUp" : "arrowDown",
                text: side === "BUY" ? "B" : "S",
              });
            }
          }
        });

        // 一次性灌入（完整语义）
        closeSeries.setData(closeData);
        hmmBgSeries.setData(hmmBgData);
        forceSeries.setData(forceData);
        ptSpeedSeries.setData(ptSpeedData);
        forceTrendSeries.setData(forceTrendData);
        regimeSeries.setData(regimeData);
        closeSeries.setMarkers(orderMarkers);

        closeChart.timeScale().fitContent();
        regimeChart.timeScale().fitContent();
        forceChart.timeScale().fitContent();
        return;
      }

      // ========= realtime =========
      pushPoint(data);
    });



    function resizeCharts() {
      const width = document.body.clientWidth - 24;
      closeChart.applyOptions({ width });
      regimeChart.applyOptions({ width });
      forceChart.applyOptions({ width });
    }

    window.addEventListener("resize", resizeCharts);
    resizeCharts();
  </script>
</body>
</html>
